collapse_and_trim <- function(x) {
  glue::glue_collapse(x, sep = ", ", width = 30L)
}

is_unbounded <- function(x) {
  identical(x, Inf)
}

check_is_list <- function(.l) {
  if (!is.list(.l)) {
    abort(paste0("`.l` must be a list, not ", vec_ptype_full(.l), "."))
  }

  invisible(.l)
}

# Thrown to here from C
stop_not_all_size_one <- function(iteration, size) {
  message <- glue::glue(
    "In iteration {iteration}, the result of `.f` had size {size}, not 1."
  )
  abort(message)
}

# Thrown to here from C
stop_slide_start_past_stop <- function(starts, stops) {
  start_after_stop <- vec_compare(starts, stops) == 1L

  at <- which(start_after_stop)
  at <- collapse_and_trim(at)

  message <- glue::glue(paste0(
    "In the ranges generated by `.before` and `.after`, ",
    "the start of the range is after the end of the range at location(s): {at}."
  ))

  abort(message)
}

# Thrown to here from C
stop_hop_start_past_stop <- function(starts, stops) {
  start_after_stop <- vec_compare(starts, stops) == 1L

  at <- which(start_after_stop)
  at <- collapse_and_trim(at)

  message <- glue::glue(paste0(
    "In the ranges generated by `.starts` and `.stops`, ",
    "a start is after a stop at location(s): {at}."
  ))

  abort(message)
}

compute_size <- function(x, type) {
  SLIDE <- -1L
  PSLIDE_EMPTY <- 0L

  if (type == SLIDE) {
    vec_size(x)
  } else if (type == PSLIDE_EMPTY) {
    0L
  } else {
    vec_size(x[[1L]])
  }
}

# Unconditionally use only the names from `.x` on the output when simplifying.
# Ensures that the following are aligned:
#
# slide_vec(c(x = 1), ~c(y = 2))
# purrr::map_dbl(c(x = 1), ~c(y = 2))
#
# slide_vec(1, ~c(y = 2))
# purrr::map_dbl(1, ~c(y = 2))
vec_simplify <- function(x, ptype) {
  names <- vec_names(x)
  x <- vec_set_names(x, NULL)

  out <- list_unchop(x, ptype = ptype)

  vec_set_names(out, names)
}

compute_combined_ranks <- function(...) {
  args <- list2(...)

  # TODO: Ideally we'd set `name_spec = zap()` to drop names from both `args`
  # and its elements for performance, but that doesn't work for non-vctrs types.
  # https://github.com/r-lib/vctrs/issues/1106
  combined <- list_unchop(unname(args))

  # Expected that there are no missing values in `combined`.
  # Incomplete rows do get ranked, with missing values coming last.
  ranks <- vec_rank(combined, ties = "dense")

  n_args <- length(args)
  sizes <- list_sizes(args)
  indices <- vector("list", n_args)

  current_start <- 1L
  for(i in seq_len(n_args)) {
    next_start <- current_start + sizes[[i]]
    current_stop <- next_start - 1L
    indices[[i]] <- seq2(current_start, current_stop)
    current_start <- next_start
  }

  out <- vec_chop(ranks, indices)
  names(out) <- names(args)

  out
}
